"use strict";
// the code used within this class has been taken and modified from the following codepen owned by Barrett Sonntag:
// https://codepen.io/sosuke/pen/Pjoqqp
Object.defineProperty(exports, "__esModule", { value: true });
exports.RgbToFilterWorker = void 0;
const sheenUtil_1 = require("../../shared/functionality/sheen/sheenUtil");
const rgbColor_1 = require("./rgbColor");
class RgbToFilterWorker {
    constructor(targetRgbColor, addSheen) {
        this.targetRgbColor = targetRgbColor;
        this.reusedRgbColor = new rgbColor_1.RgbColor();
        this.addSheen = addSheen;
    }
    static fmt(filters, idx, multiplier = 1) {
        return Math.round(filters[idx] * multiplier);
    }
    generateCss(filters) {
        const prefix = this.addSheen ? `${sheenUtil_1.SheenUtil.SHEEN_FILTER_PREFIX} ` : '';
        // prettier-ignore
        // eslint-disable-next-line max-len
        return `${prefix}invert(${RgbToFilterWorker.fmt(filters, 0)}%) sepia(${RgbToFilterWorker.fmt(filters, 1)}%) saturate(${RgbToFilterWorker.fmt(filters, 2)}%) hue-rotate(${RgbToFilterWorker.fmt(filters, 3, 3.6)}deg) brightness(${RgbToFilterWorker.fmt(filters, 4)}%) contrast(${RgbToFilterWorker.fmt(filters, 5)}%)`;
    }
    loss(filters) {
        this.reusedRgbColor.setRgb(0, 0, 0);
        this.reusedRgbColor.invert(filters[0] / 100);
        this.reusedRgbColor.sepia(filters[1] / 100);
        this.reusedRgbColor.saturate(filters[2] / 100);
        this.reusedRgbColor.hueRotate(filters[3] * 3.6);
        this.reusedRgbColor.brightness(filters[4] / 100);
        this.reusedRgbColor.contrast(filters[5] / 100);
        return (Math.abs(this.reusedRgbColor.r - this.targetRgbColor.r) +
            Math.abs(this.reusedRgbColor.g - this.targetRgbColor.g) +
            Math.abs(this.reusedRgbColor.b - this.targetRgbColor.b));
    }
    static fixSpsa(value, idx) {
        let max = 100;
        if (idx === 2 /* saturate */) {
            max = 7500;
        }
        else if (idx === 4 /* brightness */ || idx === 5 /* contrast */) {
            max = 200;
        }
        if (idx === 3 /* hue-rotate */) {
            if (value > max) {
                value %= max;
            }
            else if (value < 0) {
                value = max + (value % max);
            }
        }
        else if (value < 0) {
            value = 0;
        }
        else if (value > max) {
            value = max;
        }
        return value;
    }
    spsa(A, a, c, values, iters) {
        const alpha = 1;
        const gamma = 0.16666666666666666;
        let best = [];
        let bestLoss = Infinity;
        const deltas = new Array(6);
        const highArgs = new Array(6);
        const lowArgs = new Array(6);
        for (let k = 0; k < iters; k += 1) {
            const ck = c / Math.pow(k + 1, gamma);
            for (let i = 0; i < 6; i += 1) {
                deltas[i] = Math.random() > 0.5 ? 1 : -1;
                highArgs[i] = values[i] + ck * deltas[i];
                lowArgs[i] = values[i] - ck * deltas[i];
            }
            const lossDiff = this.loss(highArgs) - this.loss(lowArgs);
            for (let i = 0; i < 6; i += 1) {
                const g = (lossDiff / (2 * ck)) * deltas[i];
                const ak = a[i] / Math.pow(A + k + 1, alpha);
                values[i] = RgbToFilterWorker.fixSpsa(values[i] - ak * g, i);
            }
            const loss = this.loss(values);
            if (loss < bestLoss) {
                best = values.slice(0);
                bestLoss = loss;
            }
        }
        return { values: best, loss: bestLoss };
    }
    solveNarrow(wide) {
        const A = wide.loss;
        const c = 2;
        const A1 = A + 1;
        const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
        return this.spsa(A, a, c, wide.values, 500);
    }
    solveWide() {
        const A = 5;
        const c = 15;
        const a = [60, 180, 18000, 600, 1.2, 1.2];
        let best = { values: [], loss: Infinity };
        for (let i = 0; best.loss > 25 && i < 3; i += 1) {
            const initial = [50, 20, 3750, 50, 100, 100];
            const result = this.spsa(A, a, c, initial, 1000);
            if (result.loss < best.loss) {
                best = result;
            }
        }
        return best;
    }
    convert() {
        const result = this.solveNarrow(this.solveWide());
        return {
            loss: result.loss,
            color: this.generateCss(result.values),
        };
    }
}
exports.RgbToFilterWorker = RgbToFilterWorker;
