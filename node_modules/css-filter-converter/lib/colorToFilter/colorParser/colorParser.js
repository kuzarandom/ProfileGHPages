"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorParser = void 0;
const regex_1 = require("../../shared/consts/regex");
const errorHandling_1 = require("../../shared/functionality/errorHandling/errorHandling");
const inputLimits_1 = require("../../shared/consts/inputLimits");
const colorFormats_1 = require("../../shared/consts/colorFormats");
const colorTypes_1 = require("../../shared/consts/colorTypes");
// eslint-disable-next-line import/no-extraneous-dependencies
const color_name_1 = __importDefault(require("color-name"));
class ColorParser {
    static validateAndParseHex(hexString) {
        if (hexString.length < inputLimits_1.MAX_COLOR_INPUT_STRING_LENGTH) {
            const isValid = hexString.match(regex_1.MATCH_HEXADECIMAL);
            if (isValid)
                return { color: hexString };
        }
        return { errorMessage: errorHandling_1.ErrorHandling.generateInputErrorMessage(colorTypes_1.ColorTypes.HEX, hexString, colorFormats_1.ColorFormats.HEX) };
    }
    // the reason why this is simply parsing the first three digits instead of the tailored format is because the number
    // of variations of different inputs is very high. E.g. these are valid RGB values:
    // rgb(1,2,3)
    // rgb(1%,2%,3%)
    // rgb(1,2,3,0.5)
    // rgb(1 2 3 / 0.5)
    // rgb(1 2 3 / 50%)
    // Hence because the first three values are always consistent integers and the fourth is irrelevant, it is simpler to
    // parse the first three integers and use them accordingly
    static parseFirstThreeIntegersFromString(color) {
        if (color.length < inputLimits_1.MAX_COLOR_INPUT_STRING_LENGTH) {
            const regexResult = color.match(regex_1.MATCH_INTEGER_AND_FLOAT_NUMBERS);
            regex_1.MATCH_INTEGER_AND_FLOAT_NUMBERS.lastIndex = 0;
            if (regexResult && regexResult.length >= 3) {
                return regexResult.slice(0, 3).map((numberString) => Number.parseInt(numberString));
            }
        }
        return null;
    }
    static validateAndParseRgb(rgbString) {
        const rgb = ColorParser.parseFirstThreeIntegersFromString(rgbString);
        if (rgb && rgb[0] >= 0 && rgb[0] <= 255 && rgb[1] >= 0 && rgb[1] <= 255 && rgb[2] >= 0 && rgb[2] <= 255) {
            return { color: rgb };
        }
        return { errorMessage: errorHandling_1.ErrorHandling.generateInputErrorMessage(colorTypes_1.ColorTypes.RGB, rgbString, colorFormats_1.ColorFormats.RGB) };
    }
    static validateAndParseHsl(hslString) {
        const hsl = ColorParser.parseFirstThreeIntegersFromString(hslString);
        if (hsl && hsl[0] >= 0 && hsl[0] <= 360 && hsl[1] >= 0 && hsl[1] <= 100 && hsl[2] >= 0 && hsl[2] <= 100) {
            return { color: hsl };
        }
        return { errorMessage: errorHandling_1.ErrorHandling.generateInputErrorMessage(colorTypes_1.ColorTypes.HSL, hslString, colorFormats_1.ColorFormats.HSL) };
    }
    static validateAndParseKeyword(keyword) {
        if (keyword.length < inputLimits_1.MAX_COLOR_INPUT_STRING_LENGTH) {
            const isValid = color_name_1.default[keyword];
            if (isValid)
                return { color: keyword };
        }
        return { errorMessage: errorHandling_1.ErrorHandling.generateInputErrorMessage(colorTypes_1.ColorTypes.KEYWORD, keyword, colorFormats_1.ColorFormats.KEYWORD) };
    }
}
exports.ColorParser = ColorParser;
// There is a unique opportunity to validate the color input when this library operates in the browser
// by creating a new element on the dom and adding the color to it to see if it is valid.
// However it was decided not to use this approach as formats like hsl(1,2,3) are invalid in html elements.
// Additionally, it can also be time consuming to create/find an element, adding color to it and validating
// that color.
