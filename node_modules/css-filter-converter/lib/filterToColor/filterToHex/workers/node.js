"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterToHexNode = void 0;
const errorHandling_1 = require("../../../shared/functionality/errorHandling/errorHandling");
const errors_1 = require("../../../shared/consts/errors");
const colorFormats_1 = require("../../../shared/consts/colorFormats");
const colorTypes_1 = require("../../../shared/consts/colorTypes");
const shared_1 = require("./shared");
class FilterToHexNode extends shared_1.FilterToHexShared {
    static cleanup(browser) {
        if (FilterToHexNode.IS_HEADLESS)
            browser === null || browser === void 0 ? void 0 : browser.close();
    }
    static returnError(errorMsg, browser) {
        const errorResult = errorHandling_1.ErrorHandling.generateErrorResult(errorMsg);
        FilterToHexNode.cleanup(browser);
        return errorResult;
    }
    static async getImageBase64ViaSVG(page) {
        const endodedScreenshotData = await page.screenshot({ encoding: FilterToHexNode.BASE_64_ENCODING });
        return `${FilterToHexNode.ENCODED_DATA_URL_PREFIX}${endodedScreenshotData}`;
    }
    static async openBrowserPage(browser) {
        const page = await browser.newPage();
        await page.setViewport({
            width: FilterToHexNode.SVG_SIDE_LENGTH_PX,
            height: FilterToHexNode.SVG_SIDE_LENGTH_PX,
        });
        return page;
    }
    static async addSVGAndValidateFilter(page, filterString) {
        const svgAddResult = await page.evaluate(shared_1.FilterToHexShared.addSVGElementsToDOMAndValidateFilter, filterString, FilterToHexNode.SVG_SIDE_LENGTH_PX);
        if (svgAddResult.errorMessage) {
            return {
                errorMessage: errorHandling_1.ErrorHandling.generateInputErrorMessage(colorTypes_1.ColorTypes.FILTER, filterString, colorFormats_1.ColorFormats.FILTER),
            };
        }
        return svgAddResult;
    }
    static async getPuppeteerDependency() {
        try {
            // this is used to prevent tsc from evaluating the puppeteer module by adding dynamicity to the require path
            const pathPadding = '';
            // eslint-disable-next-line prefer-template
            return require('puppeteer' + pathPadding);
        }
        catch (e) {
            return { errorMessage: errors_1.MUST_INSTALL_PUPPETEER };
        }
    }
    static async preparePuppeteerBrowser() {
        const puppeteer = await FilterToHexNode.getPuppeteerDependency();
        if (errorHandling_1.ErrorHandling.hasError(puppeteer))
            return puppeteer;
        return puppeteer.launch({ headless: FilterToHexNode.IS_HEADLESS });
    }
    // puppeteer versions higher than 6.0.0 have a bug where the view blinks when taking a screnshot of a specific
    // element, hence in order to not have to force the user to install a specific version of puppeteer (especially if
    // they are already using it for another use-case), the logic here is configured to reduce the viewport to the svg
    // size and then proceed to take a screenshot of the viewport via the page.screenshot api
    static async convert(filterString) {
        const browser = await FilterToHexNode.preparePuppeteerBrowser();
        if (errorHandling_1.ErrorHandling.hasError(browser))
            return FilterToHexNode.returnError(browser.errorMessage);
        const page = await FilterToHexNode.openBrowserPage(browser);
        const addSvgResult = await FilterToHexNode.addSVGAndValidateFilter(page, filterString);
        if (errorHandling_1.ErrorHandling.hasError(addSvgResult))
            return FilterToHexNode.returnError(addSvgResult.errorMessage, browser);
        const base64EncodedDataURL = await FilterToHexNode.getImageBase64ViaSVG(page);
        const hexColor = await page.evaluate(shared_1.FilterToHexShared.getColorViaImageDataURL, base64EncodedDataURL);
        FilterToHexNode.cleanup(browser);
        return { color: hexColor };
    }
}
exports.FilterToHexNode = FilterToHexNode;
FilterToHexNode.BASE_64_ENCODING = 'base64';
FilterToHexNode.ENCODED_DATA_URL_PREFIX = `data:image/png;${FilterToHexNode.BASE_64_ENCODING},`;
FilterToHexNode.IS_HEADLESS = true;
// 1px SVG/viewport length is not enough to take a screenshot when headless mode is off, hence it is set to 2px
FilterToHexNode.SVG_SIDE_LENGTH_PX = 2;
