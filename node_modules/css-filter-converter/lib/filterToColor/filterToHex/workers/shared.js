"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterToHexShared = void 0;
const errorHandling_1 = require("../../../shared/functionality/errorHandling/errorHandling");
const colorFormats_1 = require("../../../shared/consts/colorFormats");
const colorTypes_1 = require("../../../shared/consts/colorTypes");
class FilterToHexShared {
    static generateInputErrorMessage(filterString) {
        return errorHandling_1.ErrorHandling.generateInputErrorMessage(colorTypes_1.ColorTypes.FILTER, filterString, colorFormats_1.ColorFormats.FILTER);
    }
    // functions are encapsulated within a single method in order to allow them to be executed within the same context
    // of the puppeteer evaluate method
    static addSVGElementsToDOMAndValidateFilter(filterString, svgSideLength = 1) {
        function createSVGElement() {
            const xmlns = 'http://www.w3.org/2000/svg';
            const svgElement = document.createElementNS(xmlns, 'svg');
            svgElement.style.height = 'inherit';
            svgElement.style.width = 'inherit';
            svgElement.style.float = 'left';
            svgElement.style.filter = filterString;
            const rect = document.createElementNS(xmlns, 'rect');
            rect.setAttributeNS(null, 'width', svgSideLength.toString());
            rect.setAttributeNS(null, 'height', svgSideLength.toString());
            svgElement.appendChild(rect);
            return svgElement;
        }
        function createSVGContainerElement() {
            const svgContainerElement = document.createElement('div');
            svgContainerElement.style.height = `${svgSideLength}px`;
            svgContainerElement.style.width = `${svgSideLength}px`;
            svgContainerElement.style.position = 'absolute';
            svgContainerElement.style.top = '0px';
            svgContainerElement.style.left = '0px';
            return svgContainerElement;
        }
        const svgContainerElement = createSVGContainerElement();
        const svgElement = createSVGElement();
        if (svgElement.style.filter === '')
            return { errorMessage: 'error indicator', svgContainerElement };
        svgContainerElement.appendChild(svgElement);
        document.body.appendChild(svgContainerElement);
        return { svgContainerElement };
    }
    // functions are encapsulated within a single method in order to allow them to be executed within the same context
    // of the puppeteer evaluate method
    static async getColorViaImageDataURL(base64EncodedDataURL) {
        function rgbToHex(r, g, b) {
            if (r > 255 || g > 255 || b > 255)
                throw new Error('Invalid color component');
            return ((r << 16) | (g << 8) | b).toString(16);
        }
        function getData(canvasElement) {
            const canvasStartCoordinate = 0;
            const canvasFinalCoordinate = canvasElement.width;
            return canvasElement.getContext('2d').getImageData(canvasStartCoordinate, canvasStartCoordinate, canvasFinalCoordinate, canvasFinalCoordinate).data;
        }
        function getCanvasHexColor(canvasElement) {
            const data = getData(canvasElement);
            const hex = rgbToHex(data[0], data[1], data[2]);
            return `#${`000000${hex}`.slice(-6)}`;
        }
        function createCanvasElement(imageElement) {
            const canvasElement = document.createElement('canvas');
            canvasElement.width = imageElement.width;
            canvasElement.height = imageElement.height;
            canvasElement.getContext('2d').drawImage(imageElement, 0, 0, imageElement.width, imageElement.height);
            return canvasElement;
        }
        async function createImage() {
            const imageElement = new Image();
            imageElement.src = base64EncodedDataURL;
            return new Promise((resolve) => {
                setTimeout(() => resolve(imageElement));
            });
        }
        const imageElement = await createImage();
        const canvasElement = createCanvasElement(imageElement);
        return getCanvasHexColor(canvasElement);
    }
}
exports.FilterToHexShared = FilterToHexShared;
